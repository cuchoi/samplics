# (generated with --quick)

import numpy
from typing import Any, Dict, Optional, Tuple, Type, Union

DictStrNum = Dict[Union[float, int, str], Union[float, int]]

Array: Any
Number: Type[Union[float, int]]
StringNumber: Type[Union[float, int, str]]
checks: module
formats: module
linalg: module
math: module
normal: Any
np: module
pd: module

def area_stats(y: numpy.ndarray, X: numpy.ndarray, area: numpy.ndarray, error_std: float, re_std: float, a_factor: Dict[Any, float], samp_weight: Optional[numpy.ndarray]) -> Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]: ...
def covariance(area: numpy.ndarray, sigma2e: float, sigma2u: float, scale: numpy.ndarray) -> numpy.ndarray: ...
def fixed_coefficients(area: numpy.ndarray, y: numpy.ndarray, X: numpy.ndarray, sigma2e: float, sigma2u: float, scale: numpy.ndarray) -> Tuple[numpy.ndarray, numpy.ndarray]: ...
def inverse_covariance(area: numpy.ndarray, sigma2e: float, sigma2u: float, scale: numpy.ndarray) -> numpy.ndarray: ...
def iterative_fisher_scoring(method: str, area: numpy.ndarray, y: numpy.ndarray, X: numpy.ndarray, sigma2e: float, sigma2u: float, scale: numpy.ndarray, abstol: float, reltol: float, maxiter: int) -> Tuple[float, float, int, float, bool]: ...
def log_det_covariance(area: numpy.ndarray, sigma2e: float, sigma2u: float, scale: numpy.ndarray) -> float: ...
def log_likelihood(method: str, y: numpy.ndarray, X: numpy.ndarray, beta: numpy.ndarray, inv_covariance: numpy.ndarray, log_det_covariance: float) -> float: ...
def partial_derivatives(method: str, area: numpy.ndarray, y: numpy.ndarray, X: numpy.ndarray, sigma2e: float, sigma2u: float, scale: numpy.ndarray) -> Tuple[numpy.ndarray, numpy.ndarray]: ...
